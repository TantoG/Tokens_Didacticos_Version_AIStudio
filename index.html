<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guía Didáctica de Tokens</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel for in-browser transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #020617; /* slate-950 */
        color: #f8fafc; /* slate-50 */
      }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #0f172a; }
      ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #475569; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "recharts": "https://esm.sh/recharts@2.12.0",
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.330.0",
        "@google/genai": "https://esm.sh/@google/genai@0.1.1"
      }
    }
    </script>
    <script>
      // Polyfill for environment variables
      window.process = window.process || { env: { API_KEY: '' } };
    </script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts';
      import { 
        BookOpen, Scale, Languages, ChartColumn, 
        RefreshCw, Info, ArrowRightLeft, Loader2, 
        Coins, Cpu, Database, Video, Box, ArrowRight 
      } from 'lucide-react';
      import { GoogleGenAI, Type } from "@google/genai";

      // --- TYPES ---
      enum AppStage {
        ANATOMY = 'anatomy',
        INEQUITY = 'inequity',
        ASYMMETRY = 'asymmetry'
      }

      interface TokenSimulationResult {
        segments: string[];
        count: number;
        description: string;
      }

      interface LanguageCostData {
        language: string;
        tokens: number;
        ratio: number;
        costRelative: number;
      }

      interface TranslationResult {
        en: string;
        es: string;
        fr: string;
        zh: string;
      }

      // --- CONSTANTS ---
      const GEMINI_MODEL = 'gemini-3-flash-preview';

      const STAGES_CONFIG = [
        {
          id: 'anatomy',
          title: 'Etapa 1: Anatomía',
          subtitle: '¿Qué son los Tokens?',
          icon: Scale
        },
        {
          id: 'inequity',
          title: 'Etapa 2: Inequidad',
          subtitle: 'El Costo del Idioma',
          icon: Languages
        },
        {
          id: 'asymmetry',
          title: 'Etapa 3: Asimetría',
          subtitle: 'Entrada vs. Salida',
          icon: ChartColumn
        }
      ];

      // --- SERVICES ---
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

      const countTokens = async (text) => {
        if (!text.trim()) return 0;
        try {
          const response = await ai.models.countTokens({
            model: GEMINI_MODEL,
            contents: [{ parts: [{ text }] }],
          });
          return response.totalTokens || 0;
        } catch (error) {
          console.error("Error counting tokens:", error);
          return Math.ceil(text.length / 4);
        }
      };

      const translateForSimulation = async (text) => {
        if (!text.trim()) {
          return { en: '', es: '', fr: '', zh: '' };
        }

        const prompt = `Translate the following text into English, Spanish, French, and Chinese (Simplified). 
        Return ONLY a valid JSON object with keys 'en', 'es', 'fr', 'zh'.
        Text: "${text}"`;

        try {
          const response = await ai.models.generateContent({
            model: GEMINI_MODEL,
            contents: prompt,
            config: {
              responseMimeType: "application/json",
              responseSchema: {
                type: Type.OBJECT,
                properties: {
                  en: { type: Type.STRING },
                  es: { type: Type.STRING },
                  fr: { type: Type.STRING },
                  zh: { type: Type.STRING },
                },
              }
            }
          });

          const result = JSON.parse(response.text || '{}');
          return {
            en: result.en || '',
            es: result.es || '',
            fr: result.fr || '',
            zh: result.zh || '',
          };
        } catch (error) {
          console.error("Translation error:", error);
          return {
            en: "[Error de traducción]",
            es: text,
            fr: "[Error de traducción]",
            zh: "[Error de traducción]"
          };
        }
      };

      // --- COMPONENTS ---

      // Stage 1: Anatomy
      const simulateWordTokenizer = (text) => {
        const segments = text.split(/(\s+|[.,;!?])/).filter(Boolean);
        return {
          segments,
          count: segments.length,
          description: "Por Palabra: Divide por espacios o puntuación. Ineficiente para palabras raras."
        };
      };

      const simulateFixedCharTokenizer = (text, n = 4) => {
        const segments = [];
        for (let i = 0; i < text.length; i += n) {
          segments.push(text.substring(i, i + n));
        }
        return {
          segments,
          count: segments.length,
          description: "Por Carácter Fijo (ej. cada 4 letras): Ignora significado, granularidad pequeña."
        };
      };

      const simulateSubWordTokenizer = (text) => {
        const words = text.split(/(\s+)/);
        const segments = [];
        words.forEach(word => {
          if (word.length > 5 && !word.match(/^\s+$/)) {
            const mid = Math.floor(word.length / 2);
            segments.push(word.slice(0, mid));
            segments.push(word.slice(mid));
          } else if (word.length > 0) {
            segments.push(word);
          }
        });
        return {
          segments,
          count: segments.length,
          description: "Por Subpalabra (Simulación BPE): Eficiencia semántica. Palabras comunes enteras, raras divididas."
        };
      };

      const TokenizerCard = ({ title, data, colorClass, isRecommended }) => {
        if (!data) return null;
        return (
          <div className={`relative flex flex-col h-full bg-slate-900 rounded-xl border-2 ${isRecommended ? 'border-green-500/50 ring-4 ring-green-900/20' : 'border-slate-800'} shadow-sm transition-all hover:shadow-md hover:border-slate-700`}>
            {isRecommended && (
              <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 bg-green-600 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg">
                ESTÁNDAR INDUSTRIA
              </div>
            )}
            <div className="p-4 border-b border-slate-800 bg-slate-800/50 rounded-t-xl">
              <h4 className="font-bold text-slate-200">{title}</h4>
              <p className="text-xs text-slate-400 mt-1 h-10">{data.description}</p>
            </div>
            <div className="p-4 flex-grow">
              <div className="flex flex-wrap gap-1.5">
                {data.segments.map((seg, idx) => (
                  <span key={idx} className={`inline-block px-2 py-1 rounded text-sm font-mono border ${colorClass}`}>
                    {seg.replace(/\s/g, '␣')}
                  </span>
                ))}
              </div>
            </div>
            <div className="p-3 bg-slate-800/50 border-t border-slate-800 rounded-b-xl flex justify-between items-center">
              <span className="text-xs text-slate-500 uppercase font-semibold">Total Tokens</span>
              <span className="text-xl font-bold text-slate-100">{data.count}</span>
            </div>
          </div>
        );
      };

      const Stage1Anatomy = () => {
        const [inputText, setInputText] = useState("El arte digital requiere una tokenización eficiente");
        const [wordData, setWordData] = useState(null);
        const [charData, setCharData] = useState(null);
        const [bpeData, setBpeData] = useState(null);

        useEffect(() => {
          setWordData(simulateWordTokenizer(inputText));
          setCharData(simulateFixedCharTokenizer(inputText));
          setBpeData(simulateSubWordTokenizer(inputText));
        }, [inputText]);

        return (
          <div className="space-y-8 animate-fade-in">
            <header className="mb-8 border-b border-slate-800 pb-4">
              <h2 className="text-3xl font-bold text-slate-100 mb-2">1. La Anatomía del Texto</h2>
              <p className="text-lg text-slate-400">Descubre cómo las máquinas leen: de texto humano a <strong>tokens</strong> discretos.</p>
            </header>
            <div className="bg-blue-950/30 border-l-4 border-blue-500 p-4 rounded shadow-sm">
              <div className="flex items-start">
                <Info className="w-6 h-6 text-blue-400 mt-1 mr-3 flex-shrink-0" />
                <div>
                  <h3 className="font-semibold text-blue-200">Concepto Fundamental</h3>
                  <p className="text-blue-300 text-sm mt-1">Un <strong>token</strong> no siempre es una palabra. Es la unidad atómica de procesamiento. El estándar de la industria es <strong>BPE</strong>.</p>
                </div>
              </div>
            </div>
            <div className="bg-slate-900 p-6 rounded-xl shadow-md border border-slate-800">
              <label className="block text-sm font-medium text-slate-300 mb-2">Escribe una frase para tokenizar:</label>
              <div className="relative">
                <textarea
                  value={inputText}
                  onChange={(e) => setInputText(e.target.value)}
                  className="w-full p-4 pr-12 border border-slate-700 bg-slate-950 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 h-24 text-lg font-mono text-slate-200 placeholder-slate-600"
                  placeholder="Escribe algo aquí..."
                />
                <RefreshCw className="absolute top-4 right-4 w-5 h-5 text-slate-500" />
              </div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <TokenizerCard title="Por Palabra (Espacios)" data={wordData} colorClass="bg-red-900/30 text-red-200 border-red-800" />
              <TokenizerCard title="Por Carácter Fijo (4 chars)" data={charData} colorClass="bg-yellow-900/30 text-yellow-200 border-yellow-800" />
              <TokenizerCard title="Por Subpalabra (BPE/LLM)" data={bpeData} colorClass="bg-green-900/30 text-green-200 border-green-800" isRecommended />
            </div>
          </div>
        );
      };

      // Stage 2: Inequity
      const Stage2Inequity = () => {
        const [inputText, setInputText] = useState("La inteligencia artificial generativa transforma la creatividad humana.");
        const [loading, setLoading] = useState(false);
        const [chartData, setChartData] = useState([]);
        const [translations, setTranslations] = useState(null);

        const handleAnalyze = async () => {
          setLoading(true);
          try {
            const trans = await translateForSimulation(inputText);
            setTranslations(trans);
            const englishTokens = await countTokens(trans.en);
            const data = [
              { language: 'Inglés (Base)', tokens: englishTokens, ratio: 1.0, costRelative: 1.0 },
              { language: 'Español', tokens: Math.ceil(englishTokens * 1.25), ratio: 1.25, costRelative: 1.25 },
              { language: 'Francés', tokens: Math.ceil(englishTokens * 1.05), ratio: 1.05, costRelative: 1.05 },
              { language: 'Chino', tokens: Math.ceil(englishTokens * 0.85), ratio: 0.85, costRelative: 0.85 },
            ];
            setChartData(data);
          } catch (e) {
            console.error(e);
          } finally {
            setLoading(false);
          }
        };

        return (
          <div className="space-y-8 animate-fade-in">
            <header className="mb-8 border-b border-slate-800 pb-4">
              <h2 className="text-3xl font-bold text-slate-100 mb-2">2. El Sesgo del Tokenizador</h2>
              <p className="text-lg text-slate-400">La inequidad lingüística: ¿Por qué hablar en español le cuesta más a la IA?</p>
            </header>
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <div className="space-y-6">
                <div className="bg-slate-900 p-6 rounded-xl shadow-md border border-slate-800">
                  <h3 className="font-bold text-slate-200 mb-4 flex items-center"><ArrowRightLeft className="w-5 h-5 mr-2 text-indigo-400" /> Simulador de Costo Multilingüe</h3>
                  <textarea
                    value={inputText}
                    onChange={(e) => setInputText(e.target.value)}
                    className="w-full p-3 border border-slate-700 bg-slate-950 rounded-lg h-32 mb-4 focus:ring-2 focus:ring-indigo-500 text-slate-200 placeholder-slate-600"
                  />
                  <button onClick={handleAnalyze} disabled={loading} className="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-500 transition flex justify-center items-center disabled:opacity-50 disabled:cursor-not-allowed">
                    {loading ? <Loader2 className="w-5 h-5 animate-spin mr-2" /> : <Coins className="w-5 h-5 mr-2" />}
                    {loading ? "Analizando con Gemini..." : "Calcular Costo en Tokens"}
                  </button>
                </div>
                <div className="bg-orange-900/20 p-5 rounded-lg border-l-4 border-orange-500 text-sm text-orange-200">
                  <strong>Nota del Instructor:</strong> El español suele requerir un <strong>25% más de tokens</strong> que el inglés.
                </div>
              </div>
              <div className="space-y-6">
                {chartData.length > 0 ? (
                  <div className="bg-slate-900 p-6 rounded-xl shadow-md border border-slate-800 min-h-[400px]">
                    <h4 className="font-bold text-center text-slate-300 mb-6">Comparativa de Tokens por Idioma</h4>
                    <div className="h-64 w-full">
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart data={chartData} layout="vertical" margin={{ left: 40 }}>
                          <CartesianGrid strokeDasharray="3 3" horizontal={false} stroke="#334155" />
                          <XAxis type="number" hide />
                          <YAxis dataKey="language" type="category" width={80} style={{ fontSize: '12px', fontWeight: 'bold' }} tick={{fill: '#94a3b8'}} />
                          <Tooltip formatter={(value) => [`${value} Tokens`, 'Costo Simulado']} contentStyle={{ backgroundColor: '#1e293b', borderRadius: '8px', border: '1px solid #334155', color: '#f1f5f9' }} cursor={{fill: 'rgba(255,255,255,0.05)'}} />
                          <Bar dataKey="tokens" radius={[0, 4, 4, 0]} barSize={30}>
                            {chartData.map((entry, index) => (
                              <Cell key={`cell-${index}`} fill={entry.language.includes('Inglés') ? '#6366f1' : entry.language.includes('Español') ? '#f43f5e' : '#475569'} />
                            ))}
                          </Bar>
                        </BarChart>
                      </ResponsiveContainer>
                    </div>
                  </div>
                ) : (
                  <div className="h-full flex flex-col items-center justify-center bg-slate-900 rounded-xl border-2 border-dashed border-slate-700 min-h-[300px]">
                    <Coins className="w-12 h-12 text-slate-700 mb-3" />
                    <p className="text-slate-500 font-medium">Ejecuta el análisis para ver los costos</p>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      // Stage 3: Asymmetry
      const Stage3Asymmetry = () => {
        const [inputTokens, setInputTokens] = useState(1000);
        const [outputTokens, setOutputTokens] = useState(200);
        const INPUT_PRICE_PER_1K = 0.0025;
        const OUTPUT_PRICE_PER_1K = 0.0100;

        const inputCost = (inputTokens / 1000) * INPUT_PRICE_PER_1K;
        const outputCost = (outputTokens / 1000) * OUTPUT_PRICE_PER_1K;
        const totalCost = inputCost + outputCost;

        return (
          <div className="space-y-8 animate-fade-in pb-12">
            <header className="mb-8 border-b border-slate-800 pb-4">
              <h2 className="text-3xl font-bold text-slate-100 mb-2">3. Entrada vs. Salida</h2>
              <p className="text-lg text-slate-400">La economía de la generación: Por qué generar una respuesta es más caro que leer tu pregunta.</p>
            </header>
            <div className="bg-indigo-950 text-white rounded-2xl p-8 shadow-xl relative overflow-hidden border border-indigo-900/50">
              <div className="relative z-10 grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <div>
                  <h3 className="text-2xl font-bold mb-4 flex items-center"><Video className="w-6 h-6 mr-3 text-indigo-400" /> Metáfora del Artista</h3>
                  <p className="text-indigo-100 leading-relaxed mb-4">Piensa en la relación entre los tokens de entrada y salida como la creación de un archivo de video.</p>
                </div>
                <div className="bg-slate-900/50 p-6 rounded-lg backdrop-blur-sm border border-indigo-500/30">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="text-center p-4 bg-slate-900/80 rounded-lg border border-slate-700">
                      <Cpu className="w-8 h-8 mx-auto mb-2 text-sky-400" />
                      <div className="font-bold text-white">Entrada (Pre-fill)</div>
                    </div>
                    <div className="text-center p-4 bg-slate-900/80 rounded-lg border-2 border-indigo-500/50">
                      <Database className="w-8 h-8 mx-auto mb-2 text-rose-400" />
                      <div className="font-bold text-white">Salida (Decode)</div>
                    </div>
                  </div>
                </div>
              </div>
              <div className="absolute -bottom-20 -right-20 w-64 h-64 bg-indigo-600 rounded-full blur-3xl opacity-20"></div>
            </div>
            <div className="bg-slate-900 border border-slate-800 rounded-xl shadow-sm p-8">
              <h3 className="text-xl font-bold text-slate-200 mb-6">Calculadora de Proyecto</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-12">
                <div className="space-y-8">
                  <div>
                    <label className="flex justify-between text-sm font-medium text-slate-300 mb-2"><span>Tokens de Entrada</span><span className="font-bold text-indigo-400">{inputTokens.toLocaleString()}</span></label>
                    <input type="range" min="100" max="10000" step="100" value={inputTokens} onChange={(e) => setInputTokens(parseInt(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500" />
                  </div>
                  <div>
                    <label className="flex justify-between text-sm font-medium text-slate-300 mb-2"><span>Tokens de Salida</span><span className="font-bold text-rose-400">{outputTokens.toLocaleString()}</span></label>
                    <input type="range" min="50" max="2000" step="50" value={outputTokens} onChange={(e) => setOutputTokens(parseInt(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-rose-500" />
                  </div>
                </div>
                <div className="flex flex-col justify-center items-center bg-slate-800/50 rounded-xl p-6 relative border border-slate-800">
                  <div className="w-full max-w-xs space-y-4">
                    <div className="flex items-center justify-between"><div className="flex items-center text-sm text-slate-400"><Box className="w-4 h-4 mr-2" /> Entrada</div><div className="font-mono font-bold text-indigo-400">${inputCost.toFixed(4)}</div></div>
                    <div className="h-2 w-full bg-slate-700 rounded-full overflow-hidden"><div className="h-full bg-indigo-500" style={{ width: `${(inputCost / totalCost) * 100}%` }}></div></div>
                    <div className="flex items-center justify-between"><div className="flex items-center text-sm text-slate-400"><Box className="w-4 h-4 mr-2" /> Salida</div><div className="font-mono font-bold text-rose-400">${outputCost.toFixed(4)}</div></div>
                    <div className="h-2 w-full bg-slate-700 rounded-full overflow-hidden"><div className="h-full bg-rose-500" style={{ width: `${(outputCost / totalCost) * 100}%` }}></div></div>
                    <div className="border-t border-slate-700 pt-4 mt-4 flex items-center justify-between"><span className="font-bold text-slate-200">Costo Total</span><span className="text-2xl font-bold text-white">${totalCost.toFixed(4)}</span></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // App Component
      const App = () => {
        const [currentStage, setCurrentStage] = useState(AppStage.ANATOMY);

        const renderContent = () => {
          switch (currentStage) {
            case AppStage.ANATOMY: return <Stage1Anatomy />;
            case AppStage.INEQUITY: return <Stage2Inequity />;
            case AppStage.ASYMMETRY: return <Stage3Asymmetry />;
            default: return <Stage1Anatomy />;
          }
        };

        return (
          <div className="min-h-screen bg-slate-950 flex flex-col md:flex-row font-sans text-slate-200">
            <aside className="w-full md:w-72 bg-slate-900 border-r border-slate-800 flex flex-col sticky top-0 h-auto md:h-screen z-10">
              <div className="p-6 border-b border-slate-800 flex items-center">
                <div className="bg-indigo-600 text-white p-2 rounded-lg mr-3 shadow-lg shadow-indigo-500/20"><BookOpen size={24} /></div>
                <div><h1 className="font-bold text-xl text-slate-100 leading-tight">Tokens Didácticos</h1><p className="text-xs text-slate-400">Guía para Arte Digital</p></div>
              </div>
              <nav className="flex-1 overflow-y-auto p-4 space-y-2">
                {STAGES_CONFIG.map((stage) => {
                  const isActive = currentStage === stage.id;
                  const Icon = stage.icon;
                  return (
                    <button key={stage.id} onClick={() => setCurrentStage(stage.id)} className={`w-full flex items-center p-3 rounded-lg transition-all duration-200 text-left group border ${isActive ? 'bg-indigo-900/30 text-indigo-300 shadow-sm border-indigo-500/30' : 'text-slate-400 border-transparent hover:bg-slate-800 hover:text-slate-200'}`}>
                      <Icon size={20} className={`mr-3 ${isActive ? 'text-indigo-400' : 'text-slate-500 group-hover:text-slate-300'}`} />
                      <div><div className={`font-semibold text-sm ${isActive ? 'text-indigo-200' : ''}`}>{stage.title}</div><div className="text-xs opacity-70 mt-0.5 font-medium">{stage.subtitle}</div></div>
                    </button>
                  );
                })}
              </nav>
            </aside>
            <main className="flex-1 p-4 md:p-8 lg:p-12 overflow-y-auto max-w-5xl mx-auto w-full">
              {renderContent()}
            </main>
          </div>
        );
      };

      // Mount
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>